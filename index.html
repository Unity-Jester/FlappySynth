<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flappy Synth</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0d0221;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
    }
    canvas {
      display: block;
      image-rendering: pixelated;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const W = 480;
    const H = 640;
    canvas.width  = W;
    canvas.height = H;

    // Scale canvas to fit viewport while preserving aspect ratio
    function resize() {
      const scale = Math.min(window.innerWidth / W, window.innerHeight / H);
      canvas.style.width  = Math.floor(W * scale) + 'px';
      canvas.style.height = Math.floor(H * scale) + 'px';
    }
    window.addEventListener('resize', resize);
    resize();

    // ─── Constants ───────────────────────────────────────────────────────────────
    const GRAVITY      = 0.5;
    const JUMP_VEL     = -9;
    const TERM_VEL     = 12;
    const PIPE_SPEED   = 3;
    const PIPE_INTERVAL= 90;   // frames between pipe spawns
    const PIPE_GAP     = 160;
    const GROUND_Y     = H - 40;

    // ─── Characters ───────────────────────────────────────────────────────────────
    const CHARS = [
      {
        name: 'Orb',
        color: '#00f5ff',
        draw(ctx, b) {
          ctx.shadowColor = '#00f5ff';
          ctx.shadowBlur = 30;
          ctx.fillStyle = '#00f5ff';
          ctx.beginPath();
          ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 8;
          ctx.fillStyle = '#ffffff';
          ctx.beginPath();
          ctx.arc(b.x, b.y, b.radius * 0.45, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
        },
      },
      {
        name: 'Rocket',
        color: '#ff2079',
        draw(ctx, b) {
          const r = b.radius;
          ctx.shadowColor = '#ff2079';
          ctx.shadowBlur = 20;
          ctx.save();
          ctx.translate(b.x, b.y);
          // Body
          ctx.fillStyle = '#ff2079';
          ctx.fillRect(-r, -r * 0.5, r * 1.5, r);
          // Nose cone
          ctx.beginPath();
          ctx.moveTo(r * 0.5, -r * 0.5);
          ctx.lineTo(r * 1.6, 0);
          ctx.lineTo(r * 0.5,  r * 0.5);
          ctx.closePath();
          ctx.fill();
          // Top fin
          ctx.fillStyle = '#c0006a';
          ctx.beginPath();
          ctx.moveTo(-r * 0.2, -r * 0.5);
          ctx.lineTo(-r * 0.8, -r * 1.1);
          ctx.lineTo( r * 0.2, -r * 0.5);
          ctx.closePath();
          ctx.fill();
          // Bottom fin
          ctx.beginPath();
          ctx.moveTo(-r * 0.2,  r * 0.5);
          ctx.lineTo(-r * 0.8,  r * 1.1);
          ctx.lineTo( r * 0.2,  r * 0.5);
          ctx.closePath();
          ctx.fill();
          // Window
          ctx.shadowBlur = 6;
          ctx.fillStyle = '#ffffff';
          ctx.beginPath();
          ctx.arc(r * 0.2, 0, r * 0.28, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
          ctx.shadowBlur = 0;
        },
      },
      {
        name: 'UFO',
        color: '#39ff14',
        draw(ctx, b) {
          const r = b.radius;
          ctx.shadowColor = '#39ff14';
          ctx.shadowBlur = 24;
          ctx.save();
          ctx.translate(b.x, b.y);
          // Saucer body
          ctx.fillStyle = '#39ff14';
          ctx.beginPath();
          ctx.ellipse(0, r * 0.25, r * 1.3, r * 0.55, 0, 0, Math.PI * 2);
          ctx.fill();
          // Dome
          ctx.fillStyle = 'rgba(57,255,20,0.45)';
          ctx.beginPath();
          ctx.ellipse(0, -r * 0.1, r * 0.7, r * 0.65, 0, Math.PI, 0);
          ctx.fill();
          // Dome rim
          ctx.strokeStyle = '#39ff14';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.ellipse(0, -r * 0.1, r * 0.7, r * 0.65, 0, Math.PI, 0);
          ctx.stroke();
          ctx.lineWidth = 1;
          // Lights
          ctx.shadowBlur = 8;
          ctx.fillStyle = '#ffffff';
          [-r * 0.55, 0, r * 0.55].forEach(lx => {
            ctx.beginPath();
            ctx.arc(lx, r * 0.3, r * 0.13, 0, Math.PI * 2);
            ctx.fill();
          });
          ctx.restore();
          ctx.shadowBlur = 0;
        },
      },
      {
        name: 'Ghost',
        color: '#b829dd',
        draw(ctx, b) {
          const r = b.radius;
          ctx.shadowColor = '#b829dd';
          ctx.shadowBlur = 22;
          ctx.save();
          ctx.translate(b.x, b.y);
          ctx.fillStyle = '#b829dd';
          // Head + body
          ctx.beginPath();
          ctx.arc(0, -r * 0.15, r, Math.PI, 0);
          ctx.lineTo(r, r * 0.65);
          // Wavy bottom (3 bumps)
          ctx.quadraticCurveTo( r * 0.65, r * 1.2,  r * 0.33, r * 0.65);
          ctx.quadraticCurveTo(          0, r * 1.2, -r * 0.33, r * 0.65);
          ctx.quadraticCurveTo(-r * 0.65, r * 1.2, -r,         r * 0.65);
          ctx.closePath();
          ctx.fill();
          // Eyes — whites
          ctx.shadowBlur = 4;
          ctx.fillStyle = '#ffffff';
          ctx.beginPath();
          ctx.arc(-r * 0.32, -r * 0.2, r * 0.24, 0, Math.PI * 2);
          ctx.arc( r * 0.32, -r * 0.2, r * 0.24, 0, Math.PI * 2);
          ctx.fill();
          // Eyes — pupils
          ctx.fillStyle = '#0d0221';
          ctx.beginPath();
          ctx.arc(-r * 0.30, -r * 0.16, r * 0.11, 0, Math.PI * 2);
          ctx.arc( r * 0.34, -r * 0.16, r * 0.11, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
          ctx.shadowBlur = 0;
        },
      },
      {
        name: 'Pixel Bird',
        color: '#f7b731',
        draw(ctx, b) {
          const r  = b.radius;
          const p  = Math.max(2, Math.floor(r / 3.5));
          const ox = b.x - r;
          const oy = b.y - r * 0.9;
          ctx.shadowColor = '#f7b731';
          ctx.shadowBlur = 16;
          const grid = [
            [1,0,'#f7b731'],[2,0,'#f7b731'],
            [3,1,'#f7b731'],[4,1,'#f7b731'],[5,1,'#ffffff'],
            [6,2,'#ff8c00'],[6,3,'#ff8c00'],
            [1,2,'#f7b731'],[2,2,'#f7b731'],[3,2,'#f7b731'],[4,2,'#f7b731'],[5,2,'#f7b731'],
            [1,3,'#f7b731'],[2,3,'#f7b731'],[3,3,'#f7b731'],[4,3,'#f7b731'],[5,3,'#f7b731'],
            [0,3,'#e09000'],[0,4,'#e09000'],
            [2,4,'#f7b731'],[3,4,'#f7b731'],[4,4,'#f7b731'],
            [2,5,'#ff8c00'],[4,5,'#ff8c00'],
          ];
          grid.forEach(([col, row, color]) => {
            ctx.fillStyle = color;
            ctx.fillRect(ox + col * p, oy + row * p, p, p);
          });
          ctx.shadowBlur = 0;
        },
      },
    ];

    // ─── Game state ──────────────────────────────────────────────────────────────
    const game = {
      state: 'idle',   // 'idle' | 'playing' | 'dead'
      charIndex: Math.min(parseInt(localStorage.getItem('flappy_char') || '0', 10), CHARS.length - 1),
      frame: 0,
      score: 0,
      best:  parseInt(localStorage.getItem('flappy_best') || '0'),
      bird: { x: 120, y: H / 2, vy: 0, radius: 14 },
      pipes: [],
      particles: [],
      flash: 0,        // death flash alpha (0–1)
    };

    // ─── Input ───────────────────────────────────────────────────────────────────
    function flap() {
      if (game.state === 'idle') {
        game.state = 'playing';
      }
      if (game.state === 'playing') {
        game.bird.vy = JUMP_VEL;
      }
      if (game.state === 'dead') {
        resetGame();
      }
    }
    document.addEventListener('keydown', e => {
      if (e.code === 'Space') { e.preventDefault(); flap(); return; }
      if (game.state === 'idle') {
        if (e.code === 'ArrowLeft')  { e.preventDefault(); setChar(game.charIndex - 1); return; }
        if (e.code === 'ArrowRight') { e.preventDefault(); setChar(game.charIndex + 1); return; }
      }
    });
    canvas.addEventListener('click', e => {
      if (game.state === 'idle') {
        const rect  = canvas.getBoundingClientRect();
        const scale = W / rect.width;
        const cx    = (e.clientX - rect.left) * scale;
        if (cx < W / 3)       { setChar(game.charIndex - 1); return; }
        if (cx > (W * 2) / 3) { setChar(game.charIndex + 1); return; }
      }
      flap();
    });
    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      if (game.state === 'idle') {
        const rect  = canvas.getBoundingClientRect();
        const scale = W / rect.width;
        const cx    = (e.touches[0].clientX - rect.left) * scale;
        if (cx < W / 3)       { setChar(game.charIndex - 1); return; }
        if (cx > (W * 2) / 3) { setChar(game.charIndex + 1); return; }
      }
      flap();
    }, { passive: false });

    function resetGame() {
      game.state    = 'idle';
      game.frame    = 0;
      game.score    = 0;
      game.bird     = { x: 120, y: H / 2, vy: 0, radius: 14 };
      game.pipes    = [];
      game.particles= [];
      game.flash    = 0;
    }

    function setChar(idx) {
      game.charIndex = (idx + CHARS.length) % CHARS.length;
      localStorage.setItem('flappy_char', game.charIndex);
    }

    // ─── Static background layers ─────────────────────────────────────────────
    const stars = Array.from({ length: 80 }, () => ({
      x: Math.random() * W,
      y: Math.random() * (GROUND_Y - 60),
      r: Math.random() * 1.5 + 0.3,
      a: Math.random() * 0.5 + 0.5,
    }));

    // City silhouette: array of {x, w, h} blocks
    const cityBlocks = [];
    {
      let cx = 0;
      while (cx < W + 60) {
        const bw = 20 + Math.random() * 40;
        const bh = 30 + Math.random() * 80;
        cityBlocks.push({ x: cx, w: bw, h: bh });
        cx += bw + 2 + Math.random() * 8;
      }
    }

    // ─── Game loop ────────────────────────────────────────────────────────────────
    let lastTime = 0;
    function loop(ts) {
      const dt = Math.min(ts - lastTime, 50); // cap at 50 ms
      lastTime = ts;

      update(dt);
      draw();

      requestAnimationFrame(loop);
    }

    function update(dt) {
      game.frame++;

      if (game.state === 'idle') {
        // gentle bob
        game.bird.y = H / 2 + Math.sin(game.frame * 0.05) * 10;
        return;
      }

      if (game.state === 'playing') {
        // Gravity
        game.bird.vy = Math.min(game.bird.vy + GRAVITY, TERM_VEL);
        game.bird.y += game.bird.vy;

        // Hit floor or ceiling
        if (game.bird.y + game.bird.radius >= GROUND_Y || game.bird.y - game.bird.radius <= 0) {
          killBird();
        }
        // Spawn pipes
        if (game.frame % PIPE_INTERVAL === 0 && game.frame > 0) {
          const minY = 80;
          const maxY = GROUND_Y - PIPE_GAP - 80;
          const gapTop = minY + Math.random() * (maxY - minY);
          game.pipes.push({
            x: W + 30,
            gapTop,
            gapBot: gapTop + PIPE_GAP,
            scored: false,
            w: 52,
          });
        }

        // Move pipes
        game.pipes = game.pipes.filter(p => {
          p.x -= PIPE_SPEED;
          return p.x + p.w > -10;
        });

        const b = game.bird;
        for (const p of game.pipes) {
          const bLeft  = b.x - b.radius;
          const bRight = b.x + b.radius;
          const bTop   = b.y - b.radius;
          const bBot   = b.y + b.radius;

          const inXRange = bRight > p.x - 4 && bLeft < p.x + p.w + 4;

          if (inXRange && (bTop < p.gapTop || bBot > p.gapBot)) {
            killBird();
            break;
          }

          // Score: bird just passed pipe centre
          if (!p.scored && b.x > p.x + p.w / 2) {
            p.scored = true;
            game.score++;
          }
        }

                // Spawn particle
        if (game.frame % 2 === 0) {
          game.particles.push({
            x: game.bird.x - game.bird.radius,
            y: game.bird.y + (Math.random() - 0.5) * 8,
            vx: -(Math.random() * 1.5 + 0.5),
            vy: (Math.random() - 0.5) * 1.2,
            life: 1.0,
            r: Math.random() * 4 + 2,
          });
        }
        // Update particles
        game.particles = game.particles.filter(p => {
          p.x += p.vx;
          p.y += p.vy;
          p.life -= 0.06;
          return p.life > 0;
        });
        return;
      }

      if (game.state === 'dead') {
        // Keep falling off screen
        game.bird.vy = Math.min(game.bird.vy + GRAVITY, TERM_VEL);
        game.bird.y += game.bird.vy;
        if (game.flash > 0) game.flash -= 0.03;
        game.particles = game.particles.filter(p => {
          p.x += p.vx; p.y += p.vy; p.life -= 0.06; return p.life > 0;
        });
      }
    }

    function killBird() {
      if (game.state === 'dead') return;
      game.state = 'dead';
      game.flash = 0.7;
      if (game.score > game.best) {
        game.best = game.score;
        localStorage.setItem('flappy_best', game.best);
      }
    }

    function draw() {
      // Sky
      ctx.fillStyle = '#0d0221';
      ctx.fillRect(0, 0, W, H);

      // Stars
      stars.forEach(s => {
        ctx.globalAlpha = s.a;
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;

      // City silhouette
      ctx.fillStyle = '#1a0533';
      cityBlocks.forEach(b => {
        ctx.fillRect(b.x, GROUND_Y - b.h, b.w, b.h);
      });

      // Ground glow line
      ctx.shadowColor = '#f7b731';
      ctx.shadowBlur = 10;
      ctx.strokeStyle = '#f7b731';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, GROUND_Y);
      ctx.lineTo(W, GROUND_Y);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.lineWidth = 1;
      drawPipes();
      drawParticles();
      drawBird();
      drawHUD();
      drawOverlay();
    }

    function drawBird() {
      CHARS[game.charIndex].draw(ctx, game.bird);
    }

    function drawParticles() {
      game.particles.forEach(p => {
        ctx.globalAlpha = p.life * 0.8;
        ctx.shadowColor = CHARS[game.charIndex].color;
        ctx.shadowBlur = 6;
        ctx.fillStyle = CHARS[game.charIndex].color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r * p.life, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
    }

    function drawPipes() {
      game.pipes.forEach(p => {
        const capH = 20;
        const capW = p.w + 8;
        const capOff = (capW - p.w) / 2;

        ctx.shadowColor = '#ff2079';
        ctx.shadowBlur = 18;

        // Top pipe body
        ctx.fillStyle = '#c0006a';
        ctx.fillRect(p.x, 0, p.w, p.gapTop - capH);

        // Top pipe cap
        ctx.fillStyle = '#ff2079';
        ctx.fillRect(p.x - capOff, p.gapTop - capH, capW, capH);

        // Bottom pipe body
        ctx.fillStyle = '#c0006a';
        ctx.fillRect(p.x, p.gapBot + capH, p.w, GROUND_Y - p.gapBot - capH);

        // Bottom pipe cap
        ctx.fillStyle = '#ff2079';
        ctx.fillRect(p.x - capOff, p.gapBot, capW, capH);

        ctx.shadowBlur = 0;
      });
    }
    function drawHUD() {
      if (game.state === 'playing' || game.state === 'dead') {
        ctx.shadowColor = '#ffffff';
        ctx.shadowBlur = 12;
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 52px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(game.score, W / 2, 90);
        ctx.shadowBlur = 0;
        ctx.textAlign = 'left';
      }
    }

    function drawOverlay() {
      // Death flash
      if (game.flash > 0) {
        ctx.globalAlpha = game.flash;
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, W, H);
        ctx.globalAlpha = 1;
      }

      if (game.state === 'idle') {
        const charColor = CHARS[game.charIndex].color;

        // Title (color matches selected character)
        ctx.shadowColor = charColor;
        ctx.shadowBlur = 20;
        ctx.fillStyle = charColor;
        ctx.font = 'bold 42px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('FLAPPY SYNTH', W / 2, H / 2 - 40);
        ctx.shadowBlur = 0;

        // Left arrow (dimmed on first character)
        ctx.fillStyle = game.charIndex > 0
          ? 'rgba(255,255,255,0.85)'
          : 'rgba(255,255,255,0.25)';
        ctx.font = 'bold 36px monospace';
        ctx.fillText('<', W / 6, H / 2 + 10);

        // Right arrow (dimmed on last character)
        ctx.fillStyle = game.charIndex < CHARS.length - 1
          ? 'rgba(255,255,255,0.85)'
          : 'rgba(255,255,255,0.25)';
        ctx.fillText('>', W * 5 / 6, H / 2 + 10);

        // Character name
        ctx.fillStyle = charColor;
        ctx.font = 'bold 18px monospace';
        ctx.fillText(CHARS[game.charIndex].name, W / 2, H / 2 + 50);

        // Dot indicators
        const dotSpacing = 16;
        const dotsW = (CHARS.length - 1) * dotSpacing;
        CHARS.forEach((_, i) => {
          ctx.fillStyle = i === game.charIndex ? charColor : 'rgba(255,255,255,0.3)';
          ctx.beginPath();
          ctx.arc(W / 2 - dotsW / 2 + i * dotSpacing, H / 2 + 74, 5, 0, Math.PI * 2);
          ctx.fill();
        });

        // Prompt
        ctx.fillStyle = 'rgba(255,255,255,0.75)';
        ctx.font = '18px monospace';
        ctx.fillText('SPACE / TAP TO START', W / 2, H / 2 + 10);
      }

      if (game.state === 'dead') {
        // Dim background
        ctx.fillStyle = 'rgba(13, 2, 33, 0.65)';
        ctx.fillRect(0, 0, W, H);

        ctx.shadowColor = '#ff2079';
        ctx.shadowBlur = 24;
        ctx.fillStyle = '#ff2079';
        ctx.font = 'bold 46px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', W / 2, H / 2 - 60);
        ctx.shadowBlur = 0;

        ctx.fillStyle = '#ffffff';
        ctx.font = '28px monospace';
        ctx.fillText(`SCORE  ${game.score}`, W / 2, H / 2);
        ctx.fillText(`BEST   ${game.best}`, W / 2, H / 2 + 40);

        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.font = '18px monospace';
        ctx.fillText('SPACE / TAP TO RESTART', W / 2, H / 2 + 100);
      }
      ctx.textAlign = 'left';
    }

    requestAnimationFrame(loop);
  </script>
</body>
</html>
