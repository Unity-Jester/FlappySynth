<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flappy Synth</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0d0221;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
    }
    canvas {
      display: block;
      image-rendering: pixelated;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const W = 480;
    const H = 640;
    canvas.width  = W;
    canvas.height = H;

    // Scale canvas to fit viewport while preserving aspect ratio
    function resize() {
      const scale = Math.min(window.innerWidth / W, window.innerHeight / H);
      canvas.style.width  = Math.floor(W * scale) + 'px';
      canvas.style.height = Math.floor(H * scale) + 'px';
    }
    window.addEventListener('resize', resize);
    resize();

    // ─── Constants ───────────────────────────────────────────────────────────────
    const GRAVITY      = 0.5;
    const JUMP_VEL     = -9;
    const TERM_VEL     = 12;
    const PIPE_SPEED   = 3;
    const PIPE_INTERVAL= 90;   // frames between pipe spawns
    const PIPE_GAP     = 160;
    const GROUND_Y     = H - 40;

    // ─── Game state ──────────────────────────────────────────────────────────────
    const game = {
      state: 'idle',   // 'idle' | 'playing' | 'dead'
      frame: 0,
      score: 0,
      best:  parseInt(localStorage.getItem('flappy_best') || '0'),
      bird: { x: 120, y: H / 2, vy: 0, radius: 14 },
      pipes: [],
      particles: [],
      flash: 0,        // death flash alpha (0–1)
    };

    // ─── Input ───────────────────────────────────────────────────────────────────
    function flap() {
      if (game.state === 'idle') {
        game.state = 'playing';
      }
      if (game.state === 'playing') {
        game.bird.vy = JUMP_VEL;
      }
      if (game.state === 'dead') {
        resetGame();
      }
    }
    document.addEventListener('keydown', e => { if (e.code === 'Space') { e.preventDefault(); flap(); } });
    canvas.addEventListener('click',     flap);
    canvas.addEventListener('touchstart', e => { e.preventDefault(); flap(); }, { passive: false });

    function resetGame() {
      game.state    = 'idle';
      game.frame    = 0;
      game.score    = 0;
      game.bird     = { x: 120, y: H / 2, vy: 0, radius: 14 };
      game.pipes    = [];
      game.particles= [];
      game.flash    = 0;
    }

    // ─── Static background layers ─────────────────────────────────────────────
    const stars = Array.from({ length: 80 }, () => ({
      x: Math.random() * W,
      y: Math.random() * (GROUND_Y - 60),
      r: Math.random() * 1.5 + 0.3,
      a: Math.random() * 0.5 + 0.5,
    }));

    // City silhouette: array of {x, w, h} blocks
    const cityBlocks = [];
    {
      let cx = 0;
      while (cx < W + 60) {
        const bw = 20 + Math.random() * 40;
        const bh = 30 + Math.random() * 80;
        cityBlocks.push({ x: cx, w: bw, h: bh });
        cx += bw + 2 + Math.random() * 8;
      }
    }

    // ─── Game loop ────────────────────────────────────────────────────────────────
    let lastTime = 0;
    function loop(ts) {
      const dt = Math.min(ts - lastTime, 50); // cap at 50 ms
      lastTime = ts;

      update(dt);
      draw();

      requestAnimationFrame(loop);
    }

    function update(dt) {
      game.frame++;

      if (game.state === 'idle') {
        // gentle bob
        game.bird.y = H / 2 + Math.sin(game.frame * 0.05) * 10;
        return;
      }

      if (game.state === 'playing') {
        // Gravity
        game.bird.vy = Math.min(game.bird.vy + GRAVITY, TERM_VEL);
        game.bird.y += game.bird.vy;

        // Hit floor or ceiling
        if (game.bird.y + game.bird.radius >= GROUND_Y || game.bird.y - game.bird.radius <= 0) {
          killBird();
        }
        // Spawn pipes
        if (game.frame % PIPE_INTERVAL === 0) {
          const minY = 80;
          const maxY = GROUND_Y - PIPE_GAP - 80;
          const gapTop = minY + Math.random() * (maxY - minY);
          game.pipes.push({
            x: W + 30,
            gapTop,
            gapBot: gapTop + PIPE_GAP,
            scored: false,
            w: 52,
          });
        }

        // Move pipes
        game.pipes = game.pipes.filter(p => {
          p.x -= PIPE_SPEED;
          return p.x + p.w > -10;
        });

        const b = game.bird;
        for (const p of game.pipes) {
          const bLeft  = b.x - b.radius;
          const bRight = b.x + b.radius;
          const bTop   = b.y - b.radius;
          const bBot   = b.y + b.radius;

          const inXRange = bRight > p.x - 4 && bLeft < p.x + p.w + 4;

          if (inXRange && (bTop < p.gapTop || bBot > p.gapBot)) {
            killBird();
            break;
          }

          // Score: bird just passed pipe centre
          if (!p.scored && b.x > p.x + p.w / 2) {
            p.scored = true;
            game.score++;
          }
        }

                // Spawn particle
        if (game.frame % 2 === 0) {
          game.particles.push({
            x: game.bird.x - game.bird.radius,
            y: game.bird.y + (Math.random() - 0.5) * 8,
            vx: -(Math.random() * 1.5 + 0.5),
            vy: (Math.random() - 0.5) * 1.2,
            life: 1.0,
            r: Math.random() * 4 + 2,
          });
        }
        // Update particles
        game.particles = game.particles.filter(p => {
          p.x += p.vx;
          p.y += p.vy;
          p.life -= 0.06;
          return p.life > 0;
        });
        return;
      }

      if (game.state === 'dead') {
        // Keep falling off screen
        game.bird.vy = Math.min(game.bird.vy + GRAVITY, TERM_VEL);
        game.bird.y += game.bird.vy;
        if (game.flash > 0) game.flash -= 0.03;
        game.particles = game.particles.filter(p => {
          p.x += p.vx; p.y += p.vy; p.life -= 0.06; return p.life > 0;
        });
      }
    }

    function killBird() {
      if (game.state === 'dead') return;
      game.state = 'dead';
      game.flash = 0.7;
      if (game.score > game.best) {
        game.best = game.score;
        localStorage.setItem('flappy_best', game.best);
      }
    }

    function draw() {
      // Sky
      ctx.fillStyle = '#0d0221';
      ctx.fillRect(0, 0, W, H);

      // Stars
      stars.forEach(s => {
        ctx.globalAlpha = s.a;
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;

      // City silhouette
      ctx.fillStyle = '#1a0533';
      cityBlocks.forEach(b => {
        ctx.fillRect(b.x, GROUND_Y - b.h, b.w, b.h);
      });

      // Ground glow line
      ctx.shadowColor = '#f7b731';
      ctx.shadowBlur = 10;
      ctx.strokeStyle = '#f7b731';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, GROUND_Y);
      ctx.lineTo(W, GROUND_Y);
      ctx.stroke();
      ctx.shadowBlur = 0;
      drawPipes();
      drawParticles();
      drawBird();
      drawHUD();
    }

    function drawBird() {
      const b = game.bird;
      // outer glow
      ctx.shadowColor = '#00f5ff';
      ctx.shadowBlur = 30;
      ctx.fillStyle = '#00f5ff';
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
      ctx.fill();
      // inner bright core
      ctx.shadowBlur = 8;
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.radius * 0.45, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    function drawParticles() {
      game.particles.forEach(p => {
        ctx.globalAlpha = p.life * 0.8;
        ctx.shadowColor = '#00f5ff';
        ctx.shadowBlur = 6;
        ctx.fillStyle = '#00f5ff';
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r * p.life, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
    }

    function drawPipes() {
      game.pipes.forEach(p => {
        const capH = 20;
        const capW = p.w + 8;
        const capOff = (capW - p.w) / 2;

        ctx.shadowColor = '#ff2079';
        ctx.shadowBlur = 18;

        // Top pipe body
        ctx.fillStyle = '#c0006a';
        ctx.fillRect(p.x, 0, p.w, p.gapTop - capH);

        // Top pipe cap
        ctx.fillStyle = '#ff2079';
        ctx.fillRect(p.x - capOff, p.gapTop - capH, capW, capH);

        // Bottom pipe body
        ctx.fillStyle = '#c0006a';
        ctx.fillRect(p.x, p.gapBot + capH, p.w, GROUND_Y - p.gapBot - capH);

        // Bottom pipe cap
        ctx.fillStyle = '#ff2079';
        ctx.fillRect(p.x - capOff, p.gapBot, capW, capH);

        ctx.shadowBlur = 0;
      });
    }
    function drawHUD() {
      if (game.state === 'playing' || game.state === 'dead') {
        ctx.shadowColor = '#ffffff';
        ctx.shadowBlur = 12;
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 52px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(game.score, W / 2, 90);
        ctx.shadowBlur = 0;
      }
    }

    requestAnimationFrame(loop);
  </script>
</body>
</html>
